// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

use crate::consumer::fraud_fingerprint::Fingerprint;
use crate::consumer::fraud_rules::Rules;
use crate::consumer::fraud_verdict_reasons::VerdictReasons;
use serde::{Deserialize, Serialize};


/// ASNProperties: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ASNProperties {
    /// asn: The Autonomous System Number of the user's network.
    pub asn: String,
    /// name: Public name associated with the ASN.
    pub name: String,
    /// network: The CIDR block associated with the ASN.
    pub network: String,
}
/// BrowserProperties: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BrowserProperties {
    /// user_agent: The user agent of the user's browser.
    pub user_agent: String,
}
/// Fingerprints: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Fingerprints {
    /// network_fingerprint: Combination of signals associated with a specific network commonly known as TLS
    /// fingerprinting. 
    pub network_fingerprint: String,
    /// hardware_fingerprint: Combinations of signals to identify an operating system and architecture.
    pub hardware_fingerprint: String,
    /// browser_fingerprint: Combination of signals to identify a browser and its specific version.
    pub browser_fingerprint: String,
    /// visitor_fingerprint: Cookie-less way of identifying a unique user.
    pub visitor_fingerprint: String,
    /// visitor_id: The cookie stored on the user's device that uniquely identifies them.
    pub visitor_id: std::option::Option<String>,
    /// browser_id: Combination of VisitorID and NetworkFingerprint to create a clear identifier of a browser.
    pub browser_id: std::option::Option<String>,
}
/// IPGeoProperties: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct IPGeoProperties {
    /// city: The city where the IP is located.
    pub city: String,
    /// region: The region where the IP is located.
    pub region: String,
    /// country: The country where the IP is located.
    pub country: String,
}
/// Metadata: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Metadata {
    /// external_id: An external ID, such as a user ID, that you wish to associate with the telemetry ID.
    pub external_id: std::option::Option<String>,
    /// organization_id: The organization ID you wish to associate with the telemetry ID.
    pub organization_id: std::option::Option<String>,
    /// user_action: The user action, such as 'login', that you wish to associate with the telemetry ID.
    pub user_action: std::option::Option<String>,
}
/// NetworkProperties: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct NetworkProperties {
    /// ip_address: The IP address of the client.
    pub ip_address: String,
    /// asn: Information about the network's ASN (Autonomous System Number).
    pub asn: ASNProperties,
    /// ip_geolocation: Information about the geolocation of the user's IP address.
    pub ip_geolocation: IPGeoProperties,
    /// is_proxy: Whether the user is using a proxy.
    pub is_proxy: bool,
    /// is_vpn: Whether the user is using a VPN.
    pub is_vpn: bool,
}
/// Properties: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Properties {
    pub network_properties: NetworkProperties,
    pub browser_properties: BrowserProperties,
}
/// Rule: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Rule {
    /// rule_type: The rule type. The possible values are `VISITOR_ID`, `BROWSER_ID`, `VISITOR_FINGERPRINT`,
    /// `BROWSER_FINGERPRINT`, `HARDWARE_FINGERPRINT`, `NETWORK_FINGERPRINT`, `CIDR_BLOCK`, `ASN`, or
    /// `COUNTRY_CODE`.
    pub rule_type: RuleType,
    /// action: The action (`ALLOW`, `BLOCK`, or `CHALLENGE`) that will be returned for this rule.
    pub action: RuleAction,
    /// created_at: The time when the rule was created. Values conform to the RFC 3339 standard and are
    /// expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
    pub created_at: chrono::DateTime<chrono::Utc>,
    /// visitor_id: The visitor ID that a rule was set for.
    pub visitor_id: std::option::Option<String>,
    /// browser_id: The browser ID that a rule was set for.
    pub browser_id: std::option::Option<String>,
    /// visitor_fingerprint: The visitor fingerprint that a rule was set for.
    pub visitor_fingerprint: std::option::Option<String>,
    /// browser_fingerprint: The browser fingerprint that a rule was set for.
    pub browser_fingerprint: std::option::Option<String>,
    /// hardware_fingerprint: The hardware fingerprint that a rule was set for.
    pub hardware_fingerprint: std::option::Option<String>,
    /// network_fingerprint: The network fingerprint that a rule was set for.
    pub network_fingerprint: std::option::Option<String>,
    /// cidr_block: The CIDR block that a rule was set for. If an end user's IP address is within this CIDR
    /// block, this rule will be applied.
    pub cidr_block: std::option::Option<String>,
    /// country_code: The country code that a rule was set for.
    pub country_code: std::option::Option<String>,
    /// asn: The ASN that a rule was set for.
    pub asn: std::option::Option<String>,
    /// description: A description for the rule.
    pub description: std::option::Option<String>,
    /// expires_at: The timestamp when the rule expires. Values conform to the RFC 3339 standard and are
    /// expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
    pub expires_at: std::option::Option<chrono::DateTime<chrono::Utc>>,
    /// last_updated_at: The time when the rule was last updated. Will be null if the rule has never been
    /// updated. Values conform to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
    pub last_updated_at: std::option::Option<chrono::DateTime<chrono::Utc>>,
}
/// Verdict: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Verdict {
    /// action: The suggested action based on the fingerprint review. The available actions are:
    ///   * `ALLOW` - This is a known valid device grouping or device profile that is part of the default ALLOW
    /// listed set of known devices by Stytch. This grouping is made up of verified device profiles that match
    /// the characteristics of known/authentic traffic origins
    ///   * `BLOCK` - This is a known bad or malicious device profile that is undesirable and should be blocked
    /// from completing the privileged action in question
    ///   * `CHALLENGE` - This is an unknown or potentially malicious device that should be put through
    /// increased friction such as 2FA or other forms of extended user verification before allowing the
    /// privileged action to proceed
    /// 
    pub action: VerdictAction,
    /// reasons: A set of contextual clues to inform why a `CHALLENGE` or `BLOCK` action was suggested. For a
    /// list of possible Reasons, see
    /// [Warning Flags (Verdict Reasons)](https://stytch.com/docs/docs/fraud/guides/device-fingerprinting/reference/warning-flags-verdict-reasons).
    pub reasons: std::vec::Vec<String>,
    /// detected_device_type: The operating system and architecture that took the fingerprint.
    pub detected_device_type: String,
    /// is_authentic_device: The assessment of whether this is an authentic device. It will be false if hardware
    /// or browser deception is detected.
    pub is_authentic_device: bool,
    /// verdict_reason_overrides: A list of verdict reason overrides that were applied, if any.
    pub verdict_reason_overrides: std::vec::Vec<VerdictReasonOverride>,
    /// rule_match_type: The type of rule match that was applied (e.g. `VISITOR_ID`), if any. This field will
    /// only be present if there is a `RULE_MATCH` reason in the list of verdict reasons.
    pub rule_match_type: std::option::Option<RuleType>,
    /// rule_match_identifier: The rule that was applied (e.g. a specific visitor ID value), if any. This field
    /// will only be present if there is a `RULE_MATCH` reason in the list of verdict reasons.
    pub rule_match_identifier: std::option::Option<String>,
}
/// VerdictReasonAction: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct VerdictReasonAction {
    /// verdict_reason: The verdict reason.
    pub verdict_reason: String,
    /// default_action: The default action returned for the specified verdict reason in a fingerprint lookup
    /// when no overrides are specified.
    pub default_action: VerdictReasonActionAction,
    /// override_action: If not null, this action will be returned for the specified verdict reason in a
    /// fingerprint lookup, in place of the default action.
    pub override_action: std::option::Option<VerdictReasonActionAction>,
    /// override_created_at: The time when the override was created, if one exists. Values conform to the RFC
    /// 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
    pub override_created_at: std::option::Option<chrono::DateTime<chrono::Utc>>,
    /// override_description: A description of the override, if one exists.
    pub override_description: std::option::Option<String>,
}
/// VerdictReasonOverride: 
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct VerdictReasonOverride {
    /// verdict_reason: The verdict reason that was overridden.
    pub verdict_reason: String,
    /// override_action: The action that was applied for the given verdict reason.
    pub override_action: std::option::Option<VerdictReasonOverrideAction>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub enum RuleAction {
    #[serde(rename = "ALLOW")]
 #[default]     ALLOW,
    #[serde(rename = "CHALLENGE")]
    CHALLENGE,
    #[serde(rename = "BLOCK")]
    BLOCK,
    #[serde(rename = "NONE")]
    NONE,
}
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub enum RuleType {
    #[serde(rename = "VISITOR_ID")]
 #[default]     VISITORID,
    #[serde(rename = "BROWSER_ID")]
    BROWSERID,
    #[serde(rename = "VISITOR_FINGERPRINT")]
    VISITORFINGERPRINT,
    #[serde(rename = "BROWSER_FINGERPRINT")]
    BROWSERFINGERPRINT,
    #[serde(rename = "HARDWARE_FINGERPRINT")]
    HARDWAREFINGERPRINT,
    #[serde(rename = "NETWORK_FINGERPRINT")]
    NETWORKFINGERPRINT,
    #[serde(rename = "CIDR_BLOCK")]
    CIDRBLOCK,
    #[serde(rename = "ASN")]
    ASN,
    #[serde(rename = "COUNTRY_CODE")]
    COUNTRYCODE,
}
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub enum VerdictAction {
    #[serde(rename = "ALLOW")]
 #[default]     ALLOW,
    #[serde(rename = "CHALLENGE")]
    CHALLENGE,
    #[serde(rename = "BLOCK")]
    BLOCK,
}
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub enum VerdictReasonActionAction {
    #[serde(rename = "ALLOW")]
 #[default]     ALLOW,
    #[serde(rename = "CHALLENGE")]
    CHALLENGE,
    #[serde(rename = "BLOCK")]
    BLOCK,
}
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub enum VerdictReasonOverrideAction {
    #[serde(rename = "ALLOW")]
 #[default]     ALLOW,
    #[serde(rename = "CHALLENGE")]
    CHALLENGE,
    #[serde(rename = "BLOCK")]
    BLOCK,
}



pub struct Fraud {
  pub fingerprint: Fingerprint,
  pub rules: Rules,
  pub verdict_reasons: VerdictReasons,
}

impl Fraud {
    pub fn new(http_client: crate::client::Client) -> Self {
      Self {
        fingerprint: Fingerprint::new(http_client.clone()),
        rules: Rules::new(http_client.clone()),
        verdict_reasons: VerdictReasons::new(http_client.clone()),
      }
    }


}
